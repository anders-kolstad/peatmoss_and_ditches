---
editor: 
  markdown: 
    wrap: sentence
---

# Data exploration and cleaning {#data-exp}

```{r setup}
#| code-summary: "Load packages"
library(tidyverse)
library(readxl)
library(DT)
library(ggplot2)
library(kableExtra)
```

## Import and compile data

The data set is located on GitHub in an `xlsx` format.
The data are split into different tabs based on year.

```{r readData}
#| code-summary: "Import data set"

dat <- read_excel("data/growthData.xlsx", 
    sheet = "y2017") |>
  # remove some measurements from October (FALL2). 
  # These were measured again in November 
  # along with the rest of the quadrats.
  select(-DateFALL2,
         -HeightFALL2,
         -ObserverFALL2) |>
  # adding a variable that keeps track of which tab the data comes from
  add_column(tab_year = 2017) |>
  bind_rows(
    read_excel("data/growthData.xlsx", 
    sheet = "y2018") |>
  mutate(DateFALL = as.Date(DateFALL, "%d.%m.%Y"),
         tab_year = 2018)
         ) |>
  bind_rows(
    read_excel("data/growthData.xlsx", 
    sheet = "y2019") |>
    mutate(
      DateSUMMER = as.Date(DateSUMMER, "%d/%m/%Y"),
      DateFALL = as.Date(DateFALL, "%d/%m/%y"),
      tab_year = 2019)
  ) |>
  bind_rows(
    read_excel("data/growthData.xlsx", 
    sheet = "y2020") |>
    mutate(DateSPRING = as.Date(DateSPRING, "%d/%m/%Y"),
           tab_year = 2020)
  ) |>
  bind_rows(
    read_excel("data/growthData.xlsx", 
    sheet = "y2021") |>
      # data had explicit NAs in cells that were read as text:
    mutate(across(starts_with("Height"), as.numeric),
           tab_year = 2021)
  ) |>
  bind_rows(
    read_excel("data/growthData.xlsx", 
    sheet = "y2022") |>
    mutate(across(starts_with("Height"), as.numeric),
           Plot_no = as.numeric(Plot_no),
           Pin_no = as.numeric(Pin_no),
           tab_year = 2022) 
  )
```

Here's what the data looks like after I just row bind them:

```{r}
DT::datatable(dat)
```

</br>

I need to make this into a long format.
There are multiple date and height columns that I want to combine.
I will split the spring and fall data (ignoring the summer data) into separate sets, and then combine them again later.

```{r}
#| code-summary: "Turn into long format"

# Spring data
dat_spring <- dat |>
  select(-contains(c("FALL", "SUMMER", "diff"))) |>
  pivot_longer(cols = contains("Height"),
               values_to = "Height_cm",
               values_drop_na = T) |>
  separate_wider_delim(name, 
                       delim = "_",
                       names = c("temp", "pinPosition"),
                       too_few = "align_start") |>
  filter(str_detect(temp, "Rejected", negate = T)) |>
  mutate(pinPosition = case_when(
    is.na(pinPosition) ~ "single",
    .default = pinPosition
  )) |>
  select(-temp) |>
  add_column(season = "spring") |>
  rename(date = DateSPRING)

#names(dat) [!names(dat) %in% names(dat_spring) ]
#unique(dat_spring$pinPosition)


dat_fall <- dat |>
  select(-contains(c("SPRING", "SUMMER", "diff"))) |>
  # introduces NA, where NA was originally as text
  mutate(across(starts_with("Height"), as.numeric)) |>
  pivot_longer(cols = contains("Height"),
               values_to = "Height_cm",
               values_drop_na = T) |>
  separate_wider_delim(name, 
                       delim = "_",
                       names = c("temp", "pinPosition"),
                       too_few = "align_start") |>
  filter(str_detect(temp, "Rejected", negate = T)) |>
  mutate(pinPosition = case_when(
    is.na(pinPosition) ~ "single",
    .default = pinPosition
  )) |>
  select(-temp) |>
  add_column(season = "fall") |>
  rename(date = DateFALL)

# A check looking into the warnings introduced when turning
# Hieght columns from characters to numeric. All fine.
# ch <- dat |>
#   select(-contains(c("SPRING", "SUMMER", "diff"))) |>
#   drop_na(HeightFALL) |>
#   unite("link", c(ID, DateFALL))
# num <- dat |>
#   select(-contains(c("SPRING", "SUMMER", "diff"))) |>
#   mutate(across(starts_with("Height"), as.numeric)) |>
#   drop_na(HeightFALL) |>
#   unite("link", c(ID, DateFALL))
# ch |>
#   filter(!link %in% num$link) |>
#   View()
  

# Combining the two
dat_long <- dat_spring |>
  bind_rows(dat_fall) |>
  # merge comments and note columns
  unite("Remarks", 
        contains(c("Comment", "Notes")), 
        sep = ". ",
        na.rm=TRUE) |>
  # merge observer columns
  unite("Observer",
        contains("Observer"),
        sep = ". ",
        na.rm = TRUE) |>
  mutate(year = year(date))

rm(dat_fall, dat_spring)
```

The long data is `r nrow(dat_long)` rows.
This is too much to display as an html table on this web site, but here is a random sample of 100 rows just to illustrate.

```{r}
DT::datatable(dat_long[sample(1:nrow(dat_long), 100),])
```

</br>

## Looking for data problems

### Dates

#### Seasons

Are the dates entered correctly to match the seasons?

```{r fig-datesCheck}
#| fig.cap: "Distribution of measurement dates (months)."
dat_long |>
  ggplot() +
  geom_bar(aes(x = month(date)))+
  facet_grid(year(date)~season)
```

There are some measurements in the fall of 2020 that are wrong.
It turns out the month and day have been switched for plots 8 and 9:

```{r fig-dateCheck2}
#| fig.cap: "Checking inconsistency in date entries."
dat_long |>
  mutate(year = year(date)) |>
  filter(year == 2020,
         season == "fall") |>
  ggplot() +
  geom_bar(aes(x = date),
           color = "yellow",
           fill = "orange")+
  theme(axis.text.y = element_blank()) +
  facet_grid(Plot_no~.)
```

```{r}
#| eval: false
#| code-summary: "Confirming tht day and month have been switched."
dat_long |>
  filter(Plot_no %in% c(8, 9),
         season == "fall",
         year(date) == 2020) |>
  View()
```

I will reverse these now.

```{r}
#| code-summary: "Fix date mistake"
dat_long <- dat_long |>
  mutate(date = case_when(
    Plot_no %in% c(8,9) & date == date("2020-06-10") ~ date("2020-10-06"),
    .default = date
  ))
```

```{r fig-dateCheck3}
#| fig.cap: "Checking measurement dates after fixing mistake."
dat_long |>
  mutate(year = year(date)) |>
  filter(year == 2020,
         season == "fall") |>
  ggplot() +
  geom_bar(aes(x = date),
           color = "yellow",
           fill = "orange")+
  theme(axis.text.y = element_blank()) +
  facet_grid(Plot_no~.)
```

Then there were some errors with the dates in the spring of 2019 @fig-datesCheck.

```{r }
dat_long |>
  filter(year == 2019,
         season == "spring") |>
  mutate(month = month(date)) |>
  group_by(date, month) |>
  count()
```

Here I will assume that it is only the month that is wrong.
Fixing this now:

```{r}
#| code-summary: "Fix date mistake"
dat_long |>
  mutate(date = case_when(
    year == 2019 & date == date("2019-10-05") ~ date("2019-05-10"),
    .default = date
  )) |>
  filter(year == 2019,
         season == "spring") |>
  mutate(month = month(date)) |>
  group_by(date, month) |>
  count()

# OK

dat_long <- dat_long |>
  mutate(date = case_when(
    year == 2019 & date == date("2019-10-05") ~ date("2019-05-10"),
    .default = date
  ))
```

#### Year

```{r fig-distYears}
#| fig.cap: "Distribution of data points over the years and seasons"
dat_long |>
  ggplot() +
  geom_bar(aes(
    x = factor(year(date)),
    fill = season)) +
  labs(x = "Year")
```

I wonder why there are so relatively few observation in 2020.

```{r}
options(knitr.kable.NA = '')

dat_long |>
  mutate(tab_year = paste0("tab_year", tab_year)) |>
  group_by(tab_year, year) |>
  count() |>
  spread(year, n) |>
  knitr::kable() |>
  kable_paper(full_width = F)
```

Turns out some of the 2020 data (add to the 2020 tab) was give the wrong date.

```{r}
dat_long |>
  mutate(date = case_when(
    tab_year == 2020 & year == 2022 ~ date - years(2),
    .default = date),
         year = year(date))|>
  mutate(tab_year = paste0("tab_year", tab_year)) |>
  group_by(tab_year, year) |>
  count() |>
  spread(year, n) |>
  knitr::kable() |>
  kable_paper(full_width = F)
  
# OK

dat_long <- dat_long |>
  mutate(date = case_when(
    tab_year == 2020 & year == 2022 ~ date - years(2),
    .default = date),
         year = year(date))
```

### Height variable

A closer look at the height variable.

Here's the time series for a single pin, measured from the west.

```{r}
dat_long |>
  filter(grepl("^8.14", ID),
         pinPosition == "W2") |>
  arrange(year) |>
  select(ID, Remarks, year, season, Height_cm) |>
  datatable()
```

It appears the pin was replaced in the fall of 2019.
I must assume that what is recorded there is the height of the new pin, and is therefore not compareable to the spring value that same year.
The *new* annotation only last one time, i.e. it is not repeated the next season.
In the spring of 2021 the wire seems to have been replaced again, and then again in the fall.
In the spring of 2022 it was replaced a forth(?) time, according to the remarks.
But this time the ID is unchanged.

Conclusion.
I will calculate the growth per season, if and only if the spring and fall height are recorded on the same pin/wire.
That means I can remove seasons where the fall measurements are done on new wires.
There are also some IDs that have the suffix *old*.
In these cases there should always be one measrement for the same date with the prefix *new,* meaning I can delete all *old* measurements from the spring heights.

```{r}
dat_long |>
  separate_wider_regex(ID,
    c(ID_num = "\\d+.\\d++", text_in_ID = "\\w+"), 
    too_few = "align_start", 
    cols_remove = F) |>
  count(text_in_ID)

```

Removing those with direction in the ID

```{r}
dat_long <- dat_long|>
  separate_wider_regex(ID,
    c(ID_num = "\\d+.\\d++", text_in_ID = "\\w+"), 
    too_few = "align_start", 
    cols_remove = F) |>
  filter(!text_in_ID %in% c("NÃ˜", "SV"))
```

Then I remove those that are old in spring and new in fall.

```{r}
dat_long <- dat_long |>
  mutate(text_in_ID = case_when(
    is.na(text_in_ID) ~ "-",
    .default = text_in_ID
  )) |>
  filter(
    ifelse(text_in_ID == "old",
      season != "spring",
      TRUE
    ),
    ifelse(text_in_ID == "new",
      season != "fall",
      TRUE
    ),
  )
```

I should be able to convert `ID_num` to numeric without error

```{r}
head(as.numeric(dat_long$ID_num))
```

That's is fine.
And how does the text part of the ID look now?

```{r}
dat_long |>
  group_by(year, season) |>
  count(text_in_ID) |>
  spread(text_in_ID, n) |>
  select(-"-") |>
  kbl() |>
  kable_paper(full_width = F)
```

### Treatment

A closer look at the Treatment variable.

```{r}
dat_long |>
  count(Treatment)
```

How can Treatment be NA?

```{r}
dat_long |>
  filter(is.na(Treatment)) |>
  datatable()
```

These are all new pins, and all from the fall.
These row also don't have Pin_no and Plot_no.
Year is 2018 or 2019.
I can assume that the Treatment of the new pins are the same as the original pins (same Plot_no but without the *new* suffix).

I need to make a table with original IDs matched with the correct plot and pin number, and the correct treatment.
